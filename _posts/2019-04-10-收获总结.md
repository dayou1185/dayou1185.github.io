---
layout:     post
title:      2019-04-10 收获 总结
subtitle:   栈相关知识
date:       2019-04-10
author:     DaYou
header-img: img/post-bg-cook.jpg
catalog: true
---


## 0x1  什么是栈？
（今天欲解决pwn题目，不争气的fedore服务器下载checksec和peda插件总是出错，于是更新了一下fedore。解题的思路也受阻，所以决定先学习一下基础知识）
栈，是一种具有一定规则的数据结构，它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶。
堆栈数据结构的两种基本操作：
1. PUSH：将数据压入栈顶
2. POP  ：将栈顶数据弹出
以Linux 32位平台为例，进程有4GB大小的虚拟地址空间，其中1GB留给系统内核，3GB是进程自身拥有。一个进程大致的内存布局如下图所示
![](https://wx1.sinaimg.cn/mw1024/0079f8Holy1g1xxjbdogxj30aw0dtt8j.jpg)
注：
1. 代码段：存放可执行程序的代码，可读不可写
2. 数据段：存放程序中已经初始化的静态（全局）变量，可读写
3. bss段：存放程序中未初始化的静态（全局）变量，可读写
4. 堆（heap）：存放动态分配的内容，需要程序猿手动分配和释放
5. 栈（stack）：存放局部变量，如函数的参数、返回地址、局部变量等，有系统自动分配和释放

## 0x2  函数调用栈
### 1.  背景知识
栈增长方向：高地址->低地址
1. ESP：栈指针寄存器，指向栈顶的低地址
2. EBP：基址指针寄存器，指向栈底的高地址
3. EIP：指令指针，存储即将执行的程序指令的地址
函数调用约定：
![](https://wx2.sinaimg.cn/mw1024/0079f8Holy1g1xxjbh035j30dy05p744.jpg)

### 2. 函数调用开始
在调用一个函数时，系统会为这个函数分配一个栈帧，栈帧空间为该函数所独有。调用者调用一个函数的过程大致如下：
1. 函数参数从右到左入栈
2. 返回地址入栈
3. 上一函数ebp入栈
在上一函数ebp入栈后，就开辟了被调函数的新栈帧，接下来便是被调函数临时变量入栈等操作，如果被调函数里有继续调用新函数的操作，将继续开始上述的一系列操作，不断循环嵌套下去。下图表示函数调用过程中栈的布局情况。
![](https://wx1.sinaimg.cn/mw1024/0079f8Holy1g1xxjbcxcgj30c60bcdfn.jpg)

### 3.函数调用结束
函数调用结束时的变化，主要就是按相反的顺序将数据弹出栈：
弹出临时变量
弹出调用函数的ebp值，存到ebp寄存器中
弹出返回地址，存到eip寄存器中
返回地址即是用call指令调用函数时下一条指令的地址，存到eip中，程序就知道在调用完后继续执行下一条指令。
我们会有一个疑惑，调用函数时将函数参数从右到左入栈，调用结束时怎么没有将它们弹出？
在这里，系统并不是用POP指令将它们弹出，而是通常通过ADD ESP让它们从栈中“消失”。

## 常见的危险函数如下

```
1. 输入
  - gets，直接读取一行，忽略'\x00'
  - scanf
  - vscanf
2. 输出
  - sprintf
3. 字符串
  - strcpy，字符串复制，遇到'\x00'停止
  - strcat，字符串拼接，遇到'\x00'停止
  - bcopy
```